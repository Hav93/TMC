# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# CloudDrive2 Protocol Buffer definitions

from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import timestamp_pb2 as _timestamp_pb2

_sym_db = _symbol_database.Default()

DESCRIPTOR = _descriptor.FileDescriptor(
    name='clouddrive.proto',
    package='',
    syntax='proto3',
)

# GetTokenRequest
class GetTokenRequest(_message.Message):
    __slots__ = ['userName', 'password']
    
    def __init__(self, userName='', password=''):
        self.userName = userName
        self.password = password
    
    def SerializeToString(self):
        result = b''
        if self.userName:
            result += b'\x0a' + len(self.userName.encode()).to_bytes(1, 'big') + self.userName.encode()
        if self.password:
            result += b'\x12' + len(self.password.encode()).to_bytes(1, 'big') + self.password.encode()
        return result

# JWTToken
class JWTToken(_message.Message):
    __slots__ = ['success', 'errorMessage', 'token', 'expiration']
    
    def __init__(self):
        self.success = False
        self.errorMessage = ''
        self.token = ''
        self.expiration = None
    
    def ParseFromString(self, data):
        i = 0
        while i < len(data):
            tag = data[i]
            i += 1
            
            if tag == 0x08:  # success (field 1, varint)
                self.success = bool(data[i])
                i += 1
            elif tag == 0x12:  # errorMessage (field 2, string)
                length = data[i]
                i += 1
                self.errorMessage = data[i:i+length].decode('utf-8')
                i += length
            elif tag == 0x1a:  # token (field 3, string)
                length = data[i]
                i += 1
                self.token = data[i:i+length].decode('utf-8')
                i += length
            else:
                # Skip unknown fields
                i += 1

# GetSubFilesRequest  
class GetSubFilesRequest(_message.Message):
    __slots__ = ['path']
    
    def __init__(self, path='/'):
        self.path = path
    
    def SerializeToString(self):
        result = b''
        if self.path:
            path_bytes = self.path.encode('utf-8')
            result += b'\x0a' + len(path_bytes).to_bytes(1, 'big') + path_bytes
        return result

# 辅助函数：解析varint
def _decode_varint(data, pos):
    """解码protobuf varint，返回(value, new_pos)"""
    result = 0
    shift = 0
    while pos < len(data):
        byte = data[pos]
        pos += 1
        result |= (byte & 0x7f) << shift
        if not (byte & 0x80):
            return result, pos
        shift += 7
    return result, pos

# CloudDriveFile
class CloudDriveFile(_message.Message):
    __slots__ = ['id', 'name', 'path', 'isFolder', 'size', 'createTime', 'writeTime']
    
    def __init__(self):
        self.id = ''
        self.name = ''
        self.path = ''
        self.isFolder = False
        self.size = 0
        self.createTime = None
        self.writeTime = None
    
    def ParseFromString(self, data):
        """解析单个文件/目录项"""
        i = 0
        
        while i < len(data):
            if i >= len(data):
                break
            
            # 读取field tag
            tag, i = _decode_varint(data, i)
            wire_type = tag & 0x7
            field_number = tag >> 3
            
            if wire_type == 2:  # Length-delimited (string, bytes, message)
                length, i = _decode_varint(data, i)
                if i + length > len(data):
                    break
                value_bytes = data[i:i+length]
                i += length
                
                if field_number == 1:  # id
                    self.id = value_bytes.decode('utf-8', errors='ignore')
                elif field_number == 2:  # name
                    self.name = value_bytes.decode('utf-8', errors='ignore')
                elif field_number == 3:  # path
                    self.path = value_bytes.decode('utf-8', errors='ignore')
                elif field_number == 9:  # field 9 - 包含元数据（包括isFolder标记）
                    # 在这个嵌套消息中查找 field 8 (0x40 = field 8, wire_type 0, value 0x01 = true)
                    if b'\x40\x01' in value_bytes:
                        self.isFolder = True
                # field 6, 7 等其他字段跳过
            elif wire_type == 0:  # Varint
                value, i = _decode_varint(data, i)
                if field_number == 4:  # isFolder
                    self.isFolder = bool(value)
                elif field_number == 5:  # size
                    self.size = value
            else:
                # 其他wire type，跳过
                i += 1
        
        return self

# SubFilesReply
class SubFilesReply(_message.Message):
    __slots__ = ['subFiles']
    
    def __init__(self):
        self.subFiles = []
    
    def ParseFromString(self, data):
        """正确解析 SubFilesReply，提取所有文件/目录项"""
        self.subFiles = []
        i = 0
        
        while i < len(data):
            if i >= len(data):
                break
            
            # 读取field tag
            tag, i = _decode_varint(data, i)
            wire_type = tag & 0x7
            field_number = tag >> 3
            
            if wire_type == 2 and field_number == 1:  # subFiles (repeated message)
                # 读取消息长度
                length, i = _decode_varint(data, i)
                
                # 提取这个文件/目录项的数据
                if i + length <= len(data):
                    file_data = data[i:i+length]
                    file_obj = CloudDriveFile()
                    file_obj.ParseFromString(file_data)
                    self.subFiles.append(file_obj)
                    i += length
                else:
                    break
            else:
                # 跳过未知字段
                i += 1
        
        return self

# AddOfflineFileRequest
class AddOfflineFileRequest(_message.Message):
    __slots__ = ['urls', 'toFolder']
    
    def __init__(self, urls='', toFolder='/'):
        self.urls = urls
        self.toFolder = toFolder
    
    def SerializeToString(self):
        result = b''
        if self.urls:
            urls_bytes = self.urls.encode('utf-8')
            result += b'\x0a' + len(urls_bytes).to_bytes(1, 'big') + urls_bytes
        if self.toFolder:
            folder_bytes = self.toFolder.encode('utf-8')
            result += b'\x12' + len(folder_bytes).to_bytes(1, 'big') + folder_bytes
        return result

# FileOperationResult
class FileOperationResult(_message.Message):
    __slots__ = ['success', 'errorMessage', 'resultFilePaths']
    
    def __init__(self):
        self.success = False
        self.errorMessage = ''
        self.resultFilePaths = []
    
    def ParseFromString(self, data):
        i = 0
        while i < len(data):
            if i >= len(data):
                break
            tag = data[i]
            i += 1
            
            if tag == 0x08:  # success
                self.success = bool(data[i])
                i += 1
            elif tag == 0x12:  # errorMessage
                if i < len(data):
                    length = data[i]
                    i += 1
                    if i + length <= len(data):
                        self.errorMessage = data[i:i+length].decode('utf-8')
                        i += length
            else:
                # Skip unknown fields
                i += 1

# UploadFileRequest (用于上传本地文件到CloudDrive)
class UploadFileRequest(_message.Message):
    __slots__ = ['localPath', 'remotePath', 'fileName']
    
    def __init__(self, localPath='', remotePath='/', fileName=''):
        self.localPath = localPath
        self.remotePath = remotePath
        self.fileName = fileName
    
    def SerializeToString(self):
        result = b''
        if self.localPath:
            local_bytes = self.localPath.encode('utf-8')
            result += b'\x0a' + len(local_bytes).to_bytes(1, 'big') + local_bytes
        if self.remotePath:
            remote_bytes = self.remotePath.encode('utf-8')
            result += b'\x12' + len(remote_bytes).to_bytes(1, 'big') + remote_bytes
        if self.fileName:
            name_bytes = self.fileName.encode('utf-8')
            result += b'\x1a' + len(name_bytes).to_bytes(1, 'big') + name_bytes
        return result

# CopyFileRequest (复制文件)
class CopyFileRequest(_message.Message):
    __slots__ = ['sourcePath', 'targetPath']
    
    def __init__(self, sourcePath='', targetPath=''):
        self.sourcePath = sourcePath
        self.targetPath = targetPath
    
    def SerializeToString(self):
        result = b''
        if self.sourcePath:
            source_bytes = self.sourcePath.encode('utf-8')
            result += b'\x0a' + len(source_bytes).to_bytes(1, 'big') + source_bytes
        if self.targetPath:
            target_bytes = self.targetPath.encode('utf-8')
            result += b'\x12' + len(target_bytes).to_bytes(1, 'big') + target_bytes
        return result

# MoveFileRequest (移动文件)
class MoveFileRequest(_message.Message):
    __slots__ = ['sourcePath', 'targetPath']
    
    def __init__(self, sourcePath='', targetPath=''):
        self.sourcePath = sourcePath
        self.targetPath = targetPath
    
    def SerializeToString(self):
        result = b''
        if self.sourcePath:
            source_bytes = self.sourcePath.encode('utf-8')
            result += b'\x0a' + len(source_bytes).to_bytes(1, 'big') + source_bytes
        if self.targetPath:
            target_bytes = self.targetPath.encode('utf-8')
            result += b'\x12' + len(target_bytes).to_bytes(1, 'big') + target_bytes
        return result

# CreateFolderRequest (创建文件夹)
class CreateFolderRequest(_message.Message):
    __slots__ = ['path', 'folderName']
    
    def __init__(self, path='/', folderName=''):
        self.path = path
        self.folderName = folderName
    
    def SerializeToString(self):
        result = b''
        if self.path:
            path_bytes = self.path.encode('utf-8')
            result += b'\x0a' + len(path_bytes).to_bytes(1, 'big') + path_bytes
        if self.folderName:
            name_bytes = self.folderName.encode('utf-8')
            result += b'\x12' + len(name_bytes).to_bytes(1, 'big') + name_bytes
        return result

# DeleteFileRequest (删除文件)
class DeleteFileRequest(_message.Message):
    __slots__ = ['path']
    
    def __init__(self, path=''):
        self.path = path
    
    def SerializeToString(self):
        result = b''
        if self.path:
            path_bytes = self.path.encode('utf-8')
            result += b'\x0a' + len(path_bytes).to_bytes(1, 'big') + path_bytes
        return result

